(function(e) { // jQuery 즉시 실행 함수 시작

  // 내부 함수: 대상 요소의 위치를 계산하여 scrollTop 위치 반환
  function u(selector, options) {
    var $targetElement, offsetTop, scrollPosition;

    // 선택한 요소가 존재하지 않으면 null 반환
    if (( $targetElement = e(selector) ).length == 0) return null;

    // 해당 요소의 offset().top 위치
    offsetTop = $targetElement.offset().top;

    // anchor 위치 방식에 따라 스크롤 위치 조정
    switch (options.anchor) {
      case "middle":
        // 창 높이와 요소 높이를 계산하여 중간 위치로
        scrollPosition = offsetTop - (e(window).height() - $targetElement.outerHeight()) / 2;
        break;
      default:
      case "top":
        scrollPosition = Math.max(offsetTop, 0); // top 기준
    }

    // offset 값이 함수이면 실행해서 값 사용
    return typeof options.offset == "function"
      ? scrollPosition -= options.offset()
      : scrollPosition -= options.offset;
  }

  // 변수 이름 간략화 (축약)
  var t = "length",
      n = null,
      r = "top",
      i = "offset",
      s = "click.scrolly", // 이벤트 네임스페이스
      o = e(window);       // window 객체 jQuery 래핑

  // scrolly 플러그인 정의
  e.fn.scrolly = function(options) {
    var index, scrollTarget, scrollOffset, scrollTopPosition;
    var $this = e(this); // 현재 선택된 요소들

    // 요소가 없으면 종료
    if (this.length == 0) return $this;

    // 여러 요소라면 각각 적용 (재귀 호출)
    if (this.length > 1) {
      for (index = 0; index < this.length; index++)
        e(this[index]).scrolly(options);
      return $this;
    }

    // 내부 변수 초기화
    scrollTopPosition = n;
    scrollTarget = $this.attr("href"); // ex. "#section1"

    // href가 #으로 시작하지 않으면 적용하지 않음
    if (scrollTarget.charAt(0) != "#" || scrollTarget.length < 2)
      return $this;

    // 기본 설정값 + 사용자 설정 병합
    scrollOffset = jQuery.extend({
      anchor: r,           // 기본 위치 기준: top
      easing: "swing",     // jQuery 애니메이션 easing 효과
      offset: 0,           // 추가 offset (픽셀 또는 함수)
      parent: e("body,html"), // scrollTop 적용 대상
      pollOnce: !1,        // 한 번만 위치 계산할지 여부
      speed: 1000          // 스크롤 속도 (ms)
    }, options);

    // pollOnce 옵션이 true이면, 한 번만 위치 계산
    if (scrollOffset.pollOnce)
      scrollTopPosition = u(scrollTarget, scrollOffset);

    // 기존 이벤트 제거 후 다시 바인딩
    $this.off(s).on(s, function(e) {
      var targetScroll = (scrollTopPosition !== n)
        ? scrollTopPosition
        : u(scrollTarget, scrollOffset); // 위치 계산

      // 유효한 위치일 때만 스크롤 애니메이션 실행
      if (targetScroll !== null) {
        e.preventDefault();
        scrollOffset.parent.stop().animate({
          scrollTop: targetScroll
        }, scrollOffset.speed, scrollOffset.easing);
      }
    });
  };

})(jQuery);
